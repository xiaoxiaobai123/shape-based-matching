//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using HalconDotNet;
using System.Threading;
using shape_based_matching;
using System.Windows;
using shape_based_matching.Properties;
using System.Collections.Generic;
using MahApps.Metro.Controls;
public class coordinate
{
    public HTuple Number { get; set; }
    public HTuple X { get; set; }

    public HTuple Y { get; set; }

    public HTuple Angle { get; set; }
}

public class MatchingParameters
{
    public  static double Score { get; set; }

}

public partial class HDevelopExport
{
  public HTuple hv_ExpDefaultWinHandle = new HTuple();

    HObject ho_Dog, ho_GrayImage;
    HObject ho_ModelRegion;
    HObject ho_TemplateImage;
    HTuple hv_Width = null, hv_Height = null;
    HTuple hv_AcqHandle = null;

    HObject ho_ModelContours, ho_TransContours = null;

    HTuple hv_ModelId = null, hv_ModelRow = null, hv_ModelColumn = null;

    HTuple hv_ModelAngle = null, hv_ModelScore = null, hv_MatchingObjIdx = null, hv_Deg ;

    HTuple hv_HomMat = new HTuple();

    public bool CameraDisp_Threadflag = false;

    List<HTuple> drawing_objects = new List<HTuple>();
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {
        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
 
        //Convert the parameters for disp_text.
        if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
        {

            return;
        }
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //Restore default CoordSystem behavior.
        if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
        {
            hv_CoordSystem_COPY_INP_TMP = "image";
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        HOperatorSet.DispText(3600, hv_String, hv_CoordSystem_COPY_INP_TMP,
            hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
            hv_GenParamValue);
     
        return;
    }



    public HDevelopExport()
    {

    }
    // Local procedures 
    public void add_new_drawing_object(HTuple hv_Type, HTuple hv_WindowHandle, out HTuple hv_DrawID)
    {

        // Initialize local and output iconic variables 

        hv_DrawID = new HTuple();
        //Create a drawing object DrawID of the specified Type
        //and attach it to the graphics window WindowHandle
        //
        if ((int)(new HTuple(hv_Type.TupleEqual("rectangle1"))) != 0)
        {
            HOperatorSet.CreateDrawingObjectRectangle1(300, 300, 400, 400, out hv_DrawID);
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("circle"))) != 0)
        {
            HOperatorSet.CreateDrawingObjectCircle(300, 300, 120, out hv_DrawID);
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("rectangle2"))) != 0)
        {
            HOperatorSet.CreateDrawingObjectRectangle2(300, 300, 0, 400, 400, out hv_DrawID);
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("ellipse"))) != 0)
        {
            HOperatorSet.CreateDrawingObjectEllipse(300, 300, 0, 100, 60, out hv_DrawID);
        }
        else
        {
            throw new HalconException(
                (new HTuple("Unrecognized drawing object type.")).TupleConcat("Either not a valid type or not supported by this procedure"));
        }

        return;
    }


    public void display_results(HObject ho_EdgeAmplitude)
    {

        // Initialize local and output iconic variables 

        //Display the filtered image
      //  HOperatorSet.SetSystem("flush_graphic", "false");
        HOperatorSet.ClearWindow(hv_ExpDefaultWinHandle);
        HOperatorSet.DispObj(ho_EdgeAmplitude, hv_ExpDefaultWinHandle);
        HOperatorSet.SetSystem("flush_graphic", "true");
        return;
    }
    public void dev_open_window_fit_image(HObject ho_Image, HTuple hv_Row, HTuple hv_Column,
     HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
    {




        // Local iconic variables 

        // Local control variables 

        HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
        HTuple hv_ResizeFactor = null, hv_ImageWidth = null, hv_ImageHeight = null;
        HTuple hv_TempWidth = null, hv_TempHeight = null, hv_WindowWidth = new HTuple();
        HTuple hv_WindowHeight = null;
        // Initialize local and output iconic variables 
        hv_WindowHandle = new HTuple();
        //This procedure opens a new graphics window and adjusts the size
        //such that it fits into the limits specified by WidthLimit
        //and HeightLimit, but also maintains the correct image aspect ratio.
        //
        //If it is impossible to match the minimum and maximum extent requirements
        //at the same time (f.e. if the image is very long but narrow),
        //the maximum value gets a higher priority,
        //
        //Parse input tuple WidthLimit
        if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
        {
            hv_MinWidth = 500;
            hv_MaxWidth = 800;
        }
        else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinWidth = 0;
            hv_MaxWidth = hv_WidthLimit.Clone();
        }
        else
        {
            hv_MinWidth = hv_WidthLimit.TupleSelect(0);
            hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
        }
        //Parse input tuple HeightLimit
        if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
        {
            hv_MinHeight = 400;
            hv_MaxHeight = 600;
        }
        else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinHeight = 0;
            hv_MaxHeight = hv_HeightLimit.Clone();
        }
        else
        {
            hv_MinHeight = hv_HeightLimit.TupleSelect(0);
            hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
        }
        //
        //Test, if window size has to be changed.
        hv_ResizeFactor = 1;
        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
        //First, expand window to the minimum extents (if necessary).
        if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
            hv_ImageHeight)))) != 0)
        {
            hv_ResizeFactor = (((((hv_MinWidth.TupleReal()) / hv_ImageWidth)).TupleConcat(
                (hv_MinHeight.TupleReal()) / hv_ImageHeight))).TupleMax();
        }
        hv_TempWidth = hv_ImageWidth * hv_ResizeFactor;
        hv_TempHeight = hv_ImageHeight * hv_ResizeFactor;
        //Then, shrink window to maximum extents (if necessary).
        if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
            hv_TempHeight)))) != 0)
        {
            hv_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()) / hv_TempWidth)).TupleConcat(
                (hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin());
        }
        hv_WindowWidth = hv_ImageWidth * hv_ResizeFactor;
        hv_WindowHeight = hv_ImageHeight * hv_ResizeFactor;
        //Resize window
        //dev_open_window(...);
        HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_ImageHeight - 1, hv_ImageWidth - 1);

        return;
    }
    public HTuple process_image(HObject ho_Image, out HObject ho_EdgeAmplitude, HTuple hv_WindowHandle,
    HTuple hv_DrawID)
    {   
        // Local iconic variables 
        HObject ho_Region, ho_ImageReduced;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
        HOperatorSet.GenEmptyObj(out ho_Region);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_TransContours);
        ho_TransContours.Dispose();
        try
        {
            //Apply an Sobel edge filter on the background
            //image within the region of interest defined
            //by the drawing object.
            ho_Region.Dispose();
            HOperatorSet.GetDrawingObjectIconic(out ho_Region, hv_DrawID);
            ho_ImageReduced.Dispose();
            ho_EdgeAmplitude.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_Region, out ho_EdgeAmplitude);

            try
            {
                HOperatorSet.CreateShapeModel(ho_EdgeAmplitude, 2, (new HTuple(0)).TupleRad(),
        (new HTuple(360)).TupleRad(), (new HTuple(6.2177)).TupleRad(), (new HTuple("none")).TupleConcat(
        "no_pregeneration"), "use_polarity", ((new HTuple(10)).TupleConcat(13)).TupleConcat(4), 10, out hv_ModelId);

            }
            catch(Exception ex)
            {
                
            }
            try
            {
                ho_ModelContours.Dispose();
                HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelId, 1);

                HOperatorSet.HomMat2dIdentity(out hv_HomMat);
                HOperatorSet.HomMat2dRotate(hv_HomMat, 0, 0, 0, out hv_HomMat);

                HOperatorSet.HomMat2dTranslate(hv_HomMat, 100, 100, out hv_HomMat);


                HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_TransContours, hv_HomMat);

                //HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "white");
                //HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 1);

                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");               
                HOperatorSet.ClearWindow(hv_WindowHandle);
                HOperatorSet.DispObj(ho_TransContours, hv_WindowHandle);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "true");
                HOperatorSet.FlushBuffer(hv_WindowHandle);

                return hv_ModelId;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
                return null;
            }
            ho_Region.Dispose();
            ho_ImageReduced.Dispose();

            return null;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Region.Dispose();
            ho_ImageReduced.Dispose();
            throw HDevExpDefaultException;
        }
    }

    public void Matching(HObject Image)
    {
        List<coordinate> Lctest = new List<coordinate>();
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_TransContours);

        HOperatorSet.CreateShapeModel(Image, 2, (new HTuple(0)).TupleRad(), 
            (new HTuple(360)).TupleRad(), (new HTuple(6.2177)).TupleRad(), (new HTuple("none")).TupleConcat(
            "no_pregeneration"), "use_polarity", ((new HTuple(10)).TupleConcat(13)).TupleConcat(4), 10, out hv_ModelId);

        ho_ModelContours.Dispose();
        HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelId, 1);

        HOperatorSet.FindShapeModel(ho_Dog, hv_ModelId, (new HTuple(0)).TupleRad(),
        (new HTuple(360)).TupleRad(), MatchingParameters.Score, 0, 0.5, "least_squares", (new HTuple(2)).TupleConcat(
        1), 0.9, out hv_ModelRow, out hv_ModelColumn, out hv_ModelAngle, out hv_ModelScore);

        hv_Deg = hv_ModelAngle.TupleDeg();

        HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "red");
        HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 3);

        int totalcount = hv_ModelScore.TupleLength();


        HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");

        HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 1);

        for (hv_MatchingObjIdx = 0; (int)hv_MatchingObjIdx <= totalcount - 1; hv_MatchingObjIdx = (int)hv_MatchingObjIdx + 1)
        {
            MainWindow.cd.Add(new coordinate
            {
                Number = hv_MatchingObjIdx + 1,
                X = hv_ModelRow.TupleSelect(hv_MatchingObjIdx),
                Y = hv_ModelColumn.TupleSelect(hv_MatchingObjIdx),
                Angle = hv_Deg.TupleSelect(hv_MatchingObjIdx),

            });

            Lctest.Add(new coordinate
            {
                Number = hv_MatchingObjIdx + 1,
                X = hv_ModelRow.TupleSelect(hv_MatchingObjIdx),
                Y = hv_ModelColumn.TupleSelect(hv_MatchingObjIdx),
                Angle = hv_Deg.TupleSelect(hv_MatchingObjIdx),

            });
        }

        foreach (coordinate hs in Lctest)
        {
                                 
        }
        for (int i = 0; i < totalcount; i++)
        {
           // HOperatorSet.DispCircle(hv_ExpDefaultWinHandle, hv_ModelRow.TupleSelect(i), hv_ModelColumn.TupleSelect(i), 10);
          //  HOperatorSet.GenCircle(hv_ExpDefaultWinHandle, hv_ModelRow.TupleSelect(i), hv_ModelColumn.TupleSelect(i), 10);
        }

        for (hv_MatchingObjIdx = 0; (int)hv_MatchingObjIdx <= totalcount - 1; hv_MatchingObjIdx = (int)hv_MatchingObjIdx + 1)
        {

            HOperatorSet.DispCross(hv_ExpDefaultWinHandle, hv_ModelRow.TupleSelect(hv_MatchingObjIdx),
                hv_ModelColumn.TupleSelect(hv_MatchingObjIdx), 10, hv_ModelAngle.TupleSelect(hv_MatchingObjIdx));
 
            HOperatorSet.HomMat2dIdentity(out hv_HomMat);
            HOperatorSet.HomMat2dRotate(hv_HomMat, hv_ModelAngle.TupleSelect(hv_MatchingObjIdx),
                0, 0, out hv_HomMat);
            HOperatorSet.HomMat2dTranslate(hv_HomMat, hv_ModelRow.TupleSelect(hv_MatchingObjIdx),
                hv_ModelColumn.TupleSelect(hv_MatchingObjIdx), out hv_HomMat);
            ho_TransContours.Dispose();
            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_TransContours, hv_HomMat);



            //HOperatorSet.ClearWindow(hv_ExpDefaultWinHandle);
            //HOperatorSet.DispObj(ho_Dog, hv_ExpDefaultWinHandle);
           
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "fill");


            HOperatorSet.DispObj(ho_TransContours, hv_ExpDefaultWinHandle);

            
            HOperatorSet.SetWindowParam(hv_ExpDefaultWinHandle, "flush", "true");

            HOperatorSet.FlushBuffer(hv_ExpDefaultWinHandle);
        }




        //Matching 01: Clear model when done
        HOperatorSet.ClearShapeModel(hv_ModelId);
        //Matching 01: END of generated code for model application

     

    }


    public void clearAllDrawingObject()
    {

        if (drawing_objects == null)
            return;
        foreach (HTuple dobj in drawing_objects)
        {
            HOperatorSet.ClearDrawingObject(dobj);
        }
        drawing_objects.Clear();
    }
    public void dispCamera(HTuple Window)
    {

        string CamearType = new Settings().CameraType; 
        hv_ExpDefaultWinHandle = Window;   
        HOperatorSet.GenEmptyObj(out ho_Dog);
        ho_Dog.Dispose();
        HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, 480  - 1, 640 - 1);

        try
        {
            //HOperatorSet.OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "rgb",
            //-1, "false", "default", CamearType, 0, -1, out hv_AcqHandle);
            if (CamearType == "Balser")
            {
                HOperatorSet.OpenFramegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "default", -1, "default", -1, "false", "default", "00305316ca14_Basler_acA250014gm", 0, -1, out hv_AcqHandle);
            }
            else
            {
                HOperatorSet.OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "rgb",
            -1, "false", "default", CamearType, 0, -1, out hv_AcqHandle);
            }
        }
        catch(Exception e)
        {
            MessageBox.Show("Plz select the right camera!");
            return;
        }
        HOperatorSet.GrabImageStart(hv_AcqHandle, -1);

        while (CameraDisp_Threadflag)
        {
            HOperatorSet.GrabImageAsync(out ho_Dog, hv_AcqHandle, -1);
            HOperatorSet.DispObj(ho_Dog, hv_ExpDefaultWinHandle);            
        }
    }
 
    public  HObject ShowSubPic(HTuple Window,HObject ConvertPic)
    {
        hv_ExpDefaultWinHandle = Window;

        

 
        HOperatorSet.GetImageSize(ConvertPic, out hv_Width, out hv_Height);
      
        HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_Height - 1, hv_Width - 1);
        HOperatorSet.DispObj(ConvertPic, hv_ExpDefaultWinHandle);

        return ho_Dog;
    }
  public HObject readImage(HTuple Window, string ImagePath)
  {
       
        CameraDisp_Threadflag = false;       
        hv_ExpDefaultWinHandle = Window;
         HOperatorSet.GenEmptyObj(out ho_Dog);
        HOperatorSet.GenEmptyObj(out ho_ModelRegion);
        HOperatorSet.GenEmptyObj(out ho_TemplateImage);
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_TransContours);

        ho_Dog.Dispose();
        try
        {
            HOperatorSet.ReadImage(out ho_Dog, ImagePath);
        }
        catch(Exception e)
        {
           
            MessageBox.Show(e.ToString(), "图片太大了，请重新选择新的图片！！！");
            return null;
            //Environment.Exit(1);
        }
  //      HOperatorSet.Rgb1ToGray( ho_Dog, out ho_Dog);                    
        HOperatorSet.GetImageSize(ho_Dog, out hv_Width, out hv_Height);

        //   dev_open_window_fit_image(ho_Dog, 0, 0, -1, -1, out hv_ExpDefaultWinHandle);


        HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_Height - 1, hv_Width - 1);
        //hv_Height = hv_Height * 0.25098039215686;
        //hv_Width = hv_Width * 0.25098039215686;
        //   var window2 = Application.Current.Windows.Cast<MainWindow>()
        //.FirstOrDefault(window => window is Window2) as Window2;
        //if (hv_Height > 600)
        //{
        //    foreach (MainWindow window in Application.Current.Windows)
        //    {
        //        if (window.GetType() == typeof(MainWindow))
        //        {
        //            (window as MainWindow).HwindowShow.Width = hv_Width;
        //            (window as MainWindow).HwindowShow.Height = hv_Height;
        //        }
        //    }
        //}

        //HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 1);
        //HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "blue");
        //HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");

        HOperatorSet.DispObj(ho_Dog, hv_ExpDefaultWinHandle);
 
        return ho_Dog;
 }

  public void RunPictureMatching()
  {
        ho_ModelRegion.Dispose();
        HOperatorSet.DrawRegion(out ho_ModelRegion, hv_ExpDefaultWinHandle);

        ho_TemplateImage.Dispose();
        HOperatorSet.ReduceDomain(ho_Dog, ho_ModelRegion, out ho_TemplateImage);

        HOperatorSet.CreateShapeModel(ho_TemplateImage, 2, (new HTuple(0)).TupleRad()
    , (new HTuple(360)).TupleRad(), (new HTuple(6.2177)).TupleRad(), (new HTuple("none")).TupleConcat(
    "no_pregeneration"), "use_polarity", ((new HTuple(10)).TupleConcat(13)).TupleConcat(
    4), 10, out hv_ModelId);

        //Matching 01: get the model contour for transforming it later into the image
        ho_ModelContours.Dispose();
        HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelId, 1);
        //Matching 01: END of generated code for model initialization
        //Matching 01: BEGIN of generated code for model application
        //Matching 01: the following operations are usually moved into
        //Matching 01: that loop where the aquired images are processed
        //Matching 01: Find the model
        HOperatorSet.FindShapeModel(ho_Dog, hv_ModelId, (new HTuple(0)).TupleRad(),
            (new HTuple(360)).TupleRad(), 0.78, 17, 0.5, "least_squares", (new HTuple(2)).TupleConcat(
            1), 0.9, out hv_ModelRow, out hv_ModelColumn, out hv_ModelAngle, out hv_ModelScore);


        for (hv_MatchingObjIdx = 0; (int)hv_MatchingObjIdx <= (int)((new HTuple(hv_ModelScore.TupleLength()
            )) - 1); hv_MatchingObjIdx = (int)hv_MatchingObjIdx + 1)
        {
            HOperatorSet.HomMat2dIdentity(out hv_HomMat);
            HOperatorSet.HomMat2dRotate(hv_HomMat, hv_ModelAngle.TupleSelect(hv_MatchingObjIdx),
                0, 0, out hv_HomMat);
            HOperatorSet.HomMat2dTranslate(hv_HomMat, hv_ModelRow.TupleSelect(hv_MatchingObjIdx),
                hv_ModelColumn.TupleSelect(hv_MatchingObjIdx), out hv_HomMat);
            ho_TransContours.Dispose();
            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_TransContours,
                hv_HomMat);
            HOperatorSet.DispObj(ho_TransContours, hv_ExpDefaultWinHandle);
        }

        //Matching 01: Clear model when done
        HOperatorSet.ClearShapeModel(hv_ModelId);
        //Matching 01: END of generated code for model application

        ho_Dog.Dispose();
        ho_ModelRegion.Dispose();
        ho_TemplateImage.Dispose();
        ho_ModelContours.Dispose();
        ho_TransContours.Dispose();

    }

  public void processImage()
  {
        HOperatorSet.GenEmptyObj(out ho_GrayImage);
        ho_GrayImage.Dispose();
        try
        {
            HOperatorSet.Rgb1ToGray(ho_Dog, out ho_GrayImage);
        }
        catch(Exception e)
        {
            
        }
        HOperatorSet.DispObj(ho_GrayImage, hv_ExpDefaultWinHandle);
        //ho_GrayImage.Dispose();
  }

  public HObject closecamera()
  {
        CameraDisp_Threadflag = false;
        try
        {
            HOperatorSet.CloseFramegrabber(hv_AcqHandle);
            return ho_Dog;
        }
        catch(Exception e)
        {
            return null;
        }
  }
    public void AutoModerateGray(uint graymin,uint graymax )
    {
        if (ho_Dog == null)
        {
            MessageBox.Show("未加载任何图片");
            return;
        }

        HObject ho_Regions;
        HOperatorSet.GenEmptyObj(out ho_Regions);

        HOperatorSet.Rgb1ToGray(ho_Dog, out ho_GrayImage);
        HOperatorSet.DispObj(ho_GrayImage, hv_ExpDefaultWinHandle);
        HOperatorSet.Threshold(ho_GrayImage, out ho_Regions, graymin, graymax);
        HOperatorSet.DispObj(ho_Regions, hv_ExpDefaultWinHandle);
        
    }
    public HObject AutoModerateGray(HObject HalconPic, HWindow Halconwindow, uint graymin, uint graymax)
    {
        if (HalconPic == null)
        {
            MessageBox.Show("未加载任何图片");
            return null;
        }

        HObject ho_Regions;
        HOperatorSet.GenEmptyObj(out ho_Regions);
        HOperatorSet.SetSystem("flush_graphic", "false");
        HOperatorSet.ClearWindow(Halconwindow);
        HOperatorSet.Threshold(HalconPic, out ho_Regions, graymin, graymax);
        HOperatorSet.DispObj(ho_Regions, Halconwindow);
        HOperatorSet.SetSystem("flush_graphic", "true");
        return ho_Regions;
    }
    public void AutoThreshold()
    {
        if (ho_Dog == null)
        {
            MessageBox.Show("未加载任何图片");
            return;
        }
       
            HObject ho_Regions;
            HObject ho_Median;
            HTuple UserThreshold;
            HObject ho_RegionMaxSeparabilityLight, ho_RegionMaxSeparabilityDark, ho_RegionSmoothHistoLight, ho_RegionSmoothHistoDark,
                ho_RegionDifference, ho_RegionThreshold;
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Median);
            HOperatorSet.Rgb1ToGray(ho_Dog, out ho_GrayImage);
            HOperatorSet.DispObj(ho_GrayImage, hv_ExpDefaultWinHandle);
              // HOperatorSet.MedianImage(ho_Dog, out ho_Regions, "circle", 3, "mirrored");
        HOperatorSet.BinaryThreshold(ho_GrayImage, out ho_RegionMaxSeparabilityLight, "max_separability", "light", out UserThreshold);
        //HOperatorSet.DispObj(ho_RegionMaxSeparabilityLight, hv_ExpDefaultWinHandle);

        HOperatorSet.BinaryThreshold(ho_GrayImage, out ho_RegionMaxSeparabilityDark, "max_separability", "dark", out UserThreshold);
        //HOperatorSet.DispObj(ho_RegionMaxSeparabilityDark, hv_ExpDefaultWinHandle);
   
        HOperatorSet.BinaryThreshold(ho_GrayImage, out ho_RegionSmoothHistoLight, "smooth_histo", "light", out UserThreshold);
        //HOperatorSet.DispObj(ho_RegionSmoothHistoLight, hv_ExpDefaultWinHandle);

        HOperatorSet.BinaryThreshold(ho_GrayImage, out ho_RegionSmoothHistoDark, "smooth_histo", "dark", out UserThreshold);
        //HOperatorSet.DispObj(ho_RegionSmoothHistoDark, hv_ExpDefaultWinHandle);

        HOperatorSet.SymmDifference(ho_RegionMaxSeparabilityDark, ho_RegionSmoothHistoDark, out ho_RegionDifference);
        HOperatorSet.DispObj(ho_RegionDifference, hv_ExpDefaultWinHandle);
        
        //HOperatorSet.Threshold(ho_GrayImage, out ho_RegionThreshold, 0, UserThreshold);
        //HOperatorSet.DispObj(ho_RegionThreshold, hv_ExpDefaultWinHandle);
        
        //HOperatorSet.SymmDifference(ho_RegionThreshold, ho_RegionSmoothHistoDark, out ho_RegionDifference);
        //HOperatorSet.DispObj(ho_RegionDifference, hv_ExpDefaultWinHandle);



        //HOperatorSet.AutoThreshold(ho_Regions, out ho_Median, 1.0);
        //HOperatorSet.DispObj(ho_Median, hv_ExpDefaultWinHandle);

    }

    public void PicLookUpTable(string lookuptable)
    {
        if(ho_Dog == null)
        {
            MessageBox.Show(" 请先加载图片！");
            return;
        }
        HOperatorSet.SetLut(hv_ExpDefaultWinHandle, lookuptable);
        HOperatorSet.DispObj(ho_Dog, hv_ExpDefaultWinHandle);
    }
    public void Emphsize()
    {
         
        if (ho_Dog == null)
        {
            MessageBox.Show(" 请先加载图片！");
            return;
        }
        HOperatorSet.Emphasize(ho_Dog, out ho_Dog, 7, 7, 1.0);
        HOperatorSet.DispObj(ho_Dog, hv_ExpDefaultWinHandle);
    }

    public HObject Emphsize(HObject Ho_Image,HTuple HalconWindow)
    {

        if (Ho_Image == null)
        {
            MessageBox.Show(" 请先加载图片！");
            return null;
        }
        HOperatorSet.Emphasize(Ho_Image, out Ho_Image, 7, 7, 1.0);
        HOperatorSet.DispObj(Ho_Image, HalconWindow);

        return Ho_Image;
    }


}

public class SubWindowHalconID
{

    public static HTuple RedPictureHalconID { set; get; }
    public static HWindow RedPicrureHalconWindow { set; get; }

    public static HObject RedPic { set; get; }
    public static HObject GreenPic { set; get; }
    public static HObject BluePic { set; get; }
    public static HObject HuePic { set; get; }
    public static HObject SaturationPic { set; get; }
    public static HObject ValuePic { set; get; }
}